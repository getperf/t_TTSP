package Getperf::Command::Site::TTSP::Tsuacs;
use strict;
use warnings;
use Data::Dumper;
use Time::Piece;
use base qw(Getperf::Container);
use Getperf::Command::Site::TTSP::Master;

sub new {bless{},+shift}

sub parse {
    my ($self, $data_info) = @_;

	my %results;
	my $step = 60;
	my $DEBUG = 0;
	my $INTERVAL = 60;
#	my @headers = qw/col1 col2 col3/;

	my $AFHEAD      = '';
	my $CURTIME     = '';
	my $READPHASE   = '';
	my $hostif      = '';
	my $device      = '';
	my $dev_postfix = '';

	# デバイス情報
	my %TSEC = ();			# デバイス別タイムスタンプ

	# 採取データ
	my %WBCDAT   = ();		# ライトバックキャッシュデータ
	my %WBCONOFF = ();		# ライトバックキャッシュON/OFFデータ
	my %SUMDAT   = ();		# サマリデータ
	my %CNTDAT   = ();		# サマリデータ件数
	my %DEVCNT   = ();		# サマリデータ件数(時間別)
	my %DETAILDAT = ();		# 詳細データ
	my %TRANSDAT = ();		# 転送サイズデータ
	my %HOSTTRANSDAT = ();		# 転送サイズデータ
	my %HOSTTRANSRATE = ();	# ホストIF転送レート
	my %HOSTDAT = ();		# ホストIFデータ
	my %TRANSSUMDAT = ();		# 転送サイズサマリデータ
	my %RESPDAT = ();		# レスポンスデータ
	my %RESPSUMDAT = ();		# レスポンスサマリデータ

	# リストデータ
	my %DEVLISTALL = ();		# デバイスリスト(すべて)
	my %HOSTLIST = ();		# ホストIFリスト
	my %CTLLIST = ();		# コントローラリスト
	my %RAIDLIST = ();		# RAIDグループリスト(選択のみ)
	my %DEVLIST = ();		# デバイスリスト(選択のみ)
	my %DATELIST = ();		# タイムスタンプリスト
	my %RESPLIST = ();		# レスポンスリスト
	my %BLOCKLIST = ();		# 転送ブロックリスト

	# ライブラリRefAF.pm から参照
	my %AFSYSID = get_controllers();
	my %AFRESP  = get_response_hist();	# レスポンスリスト
	my %AFBLOCK = get_blocksize_hist();	# ブロックサイズリスト

	# ホスト別ブロックレートリスト
	my @HOSTBLKRATE = ('<__1MB/s', '<__2MB/s', '<__4MB/s', '<__8MB/s', '<_16MB/s',
		'<_32MB/s', '<_64MB/s', '>=64MB/s');

	# キャッシュパーセント分布リスト
	my @WBCPCTLIST = (10, 20, 30, 40, 50, 60, 70, 80, 90, 100);

	# read,write suffix
	my %IOSUFFIX = ('read'=>'Rd', 'write'=>'Wr');

	# レスポンスリスト変換
	for my $resp (keys %AFRESP) {
		my $respsum = $AFRESP{$resp};
		$RESPLIST{$respsum} = 1;
	}

	# ブロックサイズリスト変換
	for my $block (keys %AFBLOCK) {
		my $blocksum = $AFBLOCK{$block};
		$BLOCKLIST{$blocksum} = 1;
	}

	# デバイスリスト
	my %AFDEV = get_devices();	
	for my $devs (keys %AFDEV) {
		my @item = split("\n", $AFDEV{$devs});
		print "Load [$devs]: " . join("|", @item) . "\n" if ($DEBUG);
		for my $dev (@item) {
			$DEVLIST{$dev} = $devs;
		}
	}
	# RAIDグループリスト変換
	my %AFRAIDG = get_raid_groups();  # RAIDグループリスト
	for my $devs (keys %AFRAIDG) {
		my @item = split("\n", $AFRAIDG{$devs});
		print "Load [$devs]: " . join("|", @item) . "\n" if ($DEBUG);
		for my $dev (@item) {
			my $key = $devs . "_rg" . $dev;
			$RAIDLIST{$key} = $devs;                        # c4t11_rg0
		}
	}

	$data_info->is_remote(1);
	$data_info->step($step);
	my $host = $data_info->postfix;
	my $sec  = $data_info->start_time_sec;
	if (!$sec) {
		return;
	}

	my (%values, %devices);
	my $row = 0;
	open( IN, $data_info->input_file ) || die "@!";
	while (my $line = <IN>) {
		$line=~s/(\r|\n)*//g;	# trim return code
		print "$READPHASE:$CURTIME:$device:$line\n" if ($DEBUG);
		# ヘッダーチェック
		if ($line=~/^=== (.+) ===$/) {
			$row = 0;
			my $head = $1;
			# 一番初めに出力されるヘッダ情報を採取サイクル内の先頭ヘッダとする
			$AFHEAD = $head if (!$AFHEAD && $line =~/write-back-cache schedule/);

			if ($head eq $AFHEAD) {
				# タイムスタンプ計算
				$sec += $step;
				$CURTIME = $sec->datetime;
				# タイムスタンプリストに登録
				$DATELIST{$CURTIME} = 1;
			}
			if ($head=~/(c\d+t\d+)d/) {
				$hostif = $1;
			} elsif ($head=~/^([0-9a-f]{8})[\s\(]/) {
				$hostif = $AFSYSID{$1};
				$hostif = 'etc' if (!$hostif);
			}
			if ($line=~/RAID Group:\s+(\d*)\s+HDD/) {
				$device = $hostif . '_rg' . $1 ;
			} else {
				$device = $hostif;
			}
			if ($head=~/(c\d*t\d*)([d|:]\d*) /) {
				$device = $1 . $2;
				$dev_postfix = $1;
			}
			if ($head=~/^:(\d+)\s/) {
				$device = sprintf("%s-%02d", $hostif, $1);
			}

			# === cXtXX write-back-cache schedule information ===
			if ($head=~/write-back-cache schedule information/) {
				$READPHASE = 'WBCHIST';
			# === cXtXdX access summary information ===
			} elsif ($head=~/access summary information/) {
				$READPHASE = 'SUMMARY';
			# === 5681ea79(0:0) RAID Group: 0 HDD access information ===
			# === cXtXX RAID Group: 0 HDD transfer size information ===
			} elsif ($head=~/HDD transfer size information/) {
				$READPHASE = 'HOSTTRANSFER';
			# === cXtXX RAID Group: 0 HDD transfer rate information ===
			} elsif ($head=~/HDD transfer rate information/) {
				$READPHASE = 'HOSTTRANSRATE';
			# === cXtXdX transfer size information ===
			} elsif ($head=~/transfer size information/) {
				$READPHASE = 'TRANSFER';
			# === cXtXdX response time information ===
			} elsif ($head=~/response time information/) {
				$READPHASE = 'RESPONSE';
			# その他
			} else {
				$READPHASE = 'ETC';
			}
		} elsif ($line=~/^device\s+LDISK\s+WBC mode/) {
			$row = 0;
			$READPHASE = 'WBCONOFF';
		} elsif ($line=~/^controller unit\s+:/) {
			$READPHASE = 'ETC';
		} else {
			$row ++;
		}

		# ヘッダ部読み込み
		# 開始時刻
		if ($READPHASE eq 'ETC') {
			# インターバル
			# interval time	: 30
			if ($line=~/interval time\s*:\s*(\d+)/) {
				if ($INTERVAL) {
					print "[HEADER] interval time = $INTERVAL(specified)\n" if ($DEBUG);
				} else {
					$INTERVAL = $1;
					print "[HEADER] interval time = $INTERVAL\n" if ($DEBUG);
				}
			}
		}
		# # start time	: 2014/06/09 10:45:33
		# my $start_time = $line;
		# if ($start_time =~ /start time\s+:\s+(\d\d\d\d)\/(\d\d)\/(\d\d) (\d\d):(\d\d):(\d\d)/) {
		# 	my ($year, $month, $day, $hour, $minute, $second) = ($1, $2, $3, $4, $5, $6);
		# 	$STARTSEC = timelocal($second, $minute, $hour, $day, $month-1, $year);
		# 	$tsec = $STARTSEC - $INTERVAL;
		# 	$ENDSEC   = $STARTSEC + 300;
		# 	print "[HEADER:$READPHASE] Start time = $year/$month/$day $hour:$minute:$second\n" if ($DEBUG);
		# 	print "[HEADER] Start = $STARTSEC, End = $ENDSEC\n" if ($DEBUG);
		# }

		# コントローラキャッシュヒット率読み込み 
		# if ($READPHASE eq 'WBCONOFF') {
		# 	# データ
		# 	my $onoff;
		# 	if ($row > 0) {
		# 		if ($line=~/^(c.*?)d.*(ON|OFF)/ || $line=~/^(---).*(ON|OFF)/) {
		# 			$WBCONOFFDEV = $1 if ($1 ne '---');
		# 			$onoff = $2;
		# 			# レコード登録 key = [デバイス, オンオフ]
		# 			my $key = join(',', $WBCONOFFDEV, $onoff);
		# 			$WBCONOFF{$key} ++;
		# 		}
		# 	}
		# }

		# コントローラキャッシュヒット率読み込み 
		if ($READPHASE eq 'WBCHIST') {
			# ヘッダ
			if ($row == 0) {
				# タイムスタンプリストに登録
				$HOSTLIST{$device} = 1;

			# データ
			} else {
				if ($line=~/^\s+(\d*)% (.*)/) {
					my ($pct, $line) = ($1, $2);

					# レコード登録 key = [デバイス, タイムスタンプ, パーセント]
					my @item = split(/\s+/, $line);
					my $cnt = $item[2];
					$values{'RefAFWBC'}{$device}{$CURTIME}{$pct} += $cnt;
					$devices{'RefAFWBC'}{$device} = 1;

					my $key = join(',', $device, $CURTIME, $pct);
					$WBCDAT{$key} += $cnt;
				}
			}
		}

		# サマリ部読み込み 
		if ($READPHASE eq 'SUMMARY') {
			# ヘッダ
			if ($row == 0) {
				# タイムスタンプ計算

				# タイムスタンプリストに登録
				$DEVLISTALL{$device} = 1;
			# データ
			} else {
				if ($line=~/^(read|write)\s+(.*)/) {
					# レコード分解
					my ($cmd, $line) = ($1, $2);
					$line=~s/\*//g;			# '*'を取り除く

					# 1-4列目を取得
					my @item = split(/\s+/, $line);
					for my $iname('kb_s', 'cmd_s', 'rs', 'hdd_s') {
						my $val = shift(@item);

						# レコード登録 key = [コマンド, 項目, デバイス, タイムスタンプ]
						my $key1 = join(',', ($cmd, $iname, $device, $CURTIME));
						$DETAILDAT{$key1} += $val;
						# 合計値登録 key = [コマンド, 項目, デバイス]
						my $key2 = join(',', ($cmd, $iname, $device));
						$SUMDAT{$key2} += $val;
						# 件数登録 key = [コマンド, デバイス]
						my $key3 = join(',', ($cmd, $device));
						$CNTDAT{$key3} ++;
						# 件数登録 key = [コマンド, デバイス, タイムスタンプ]
						my $key4 = join(',', $cmd, $device, $CURTIME);
						$DEVCNT{$key4} ++;

						# コントローラ別データ登録
						if (my $ctl=$DEVLIST{$device}) {
							$CTLLIST{$ctl} = 1;

							# レコード登録 key = [コマンド, 項目, デバイス, タイムスタンプ]
							my $key1 = join(',', ($cmd, $iname, $ctl, $CURTIME));
							$DETAILDAT{$key1} += $val;

							# 合計値登録 key = [コマンド, 項目, デバイス]
							my $key2 = join(',', ($cmd, $iname, $ctl));
							$SUMDAT{$key2} += $val;
							# 件数登録 key = [コマンド, デバイス]
							my $key3 = join(',', ($cmd, $ctl));
							$CNTDAT{$key3} ++;
							# 件数登録 key = [コマンド, デバイス, タイムスタンプ]
							my $key4 = join(',', $cmd, $ctl, $CURTIME);
							$DEVCNT{$key4} ++;
						}
					}
				}
			}
		}
		
		# 転送サイズ部読込み
		if ($READPHASE eq 'TRANSFER') {
			if ($line=~/^([<|>].*B) (.*)/) {
				my ($blk, $line) = ($1, $2);
				$blk = $AFBLOCK{$blk};
				# レコード登録 key = [コマンド, デバイス, タイムスタンプ, ブロックサイズ]
				my @item = split(/\s+/, $line);
				my $readval = $item[1];
				my $writeval = $item[3];

				if (my $sumdevice = $DEVLIST{$device}) {
					# read 登録 
					{
						my $key = join(',', 'read', $device, $CURTIME, $blk);
						$TRANSDAT{$key} += $readval;
					}
					# write 登録 
					{
						my $key = join(',', 'write', $device, $CURTIME, $blk);
						$TRANSDAT{$key} += $writeval;
					}

					# read 登録 
					{
						my $key = join(',', 'read', $sumdevice, $CURTIME, $blk);
						$TRANSSUMDAT{$key} += $readval;
					}
					# write 登録 
					{
						my $key = join(',', 'write', $sumdevice, $CURTIME, $blk);
						$TRANSSUMDAT{$key} += $writeval;						
					}
				}
			}
		}

		# ホスト別転送サイズ部読込み
		if ($READPHASE eq 'HOSTTRANSFER') {
			if ($line=~/^([<|>].*B) (.*)/) {
				my ($blk, $line) = ($1, $2);
				$blk = $AFBLOCK{$blk};
				# レコード登録 key = [コマンド, デバイス, タイムスタンプ, ブロックサイズ]
				my @item = split(/\s+/, $line);
				my $readval = $item[1];
				my $writeval = $item[3];
				# read 登録 
				{
					my $key = join(',', 'read', $device, $CURTIME, $blk);
					$TRANSDAT{$key} += $readval;
				}
				# write 登録 
				{
					my $key = join(',', 'write', $device, $CURTIME, $blk);
					$TRANSDAT{$key} += $writeval;
				}
			} elsif ($line=~/^Total\s*(\w+)\s*transfer rate =\s*(.*)KB\/s$/) {
				# レコード登録 key = [コマンド, デバイス, タイムスタンプ]
				my ($cmd, $val) = ($1, $2);
				my $key = join(',', $cmd, $device, $CURTIME);
				$HOSTDAT{$key} += $val;
			}
		}

		# ホスト別転送レート部読込み
		if ($READPHASE eq 'HOSTTRANSRATE') {
			if ($line=~/^([<|>].*MB\/s) (.*)/) {
				my ($blk, $line) = ($1, $2);
				$blk=~s/\s/_/g;
				# レコード登録 key = [コマンド, デバイス, タイムスタンプ, ブロックサイズ]
				my @item = split(/\s+/, $line);
				my $readval = $item[1];
				my $writeval = $item[3];
				# read 登録 
				{
					my $key = join(',', 'read', $device, $CURTIME, $blk);
					$HOSTTRANSRATE{$key} += $readval;
				}
				# write 登録 
				{
					my $key = join(',', 'write', $device, $CURTIME, $blk);
					$HOSTTRANSRATE{$key} += $writeval;
				}
				# read(合計)登録
				{
					my $key = join(',', 'rhdd_s', $device, $CURTIME);
					$HOSTDAT{$key} += $readval;
				}
				# write(合計)登録
				{
					my $key = join(',', 'whdd_s', $device, $CURTIME);
					$HOSTDAT{$key} += $writeval;
				}
			}
		}

		# レスポンス部読込み
		if ($READPHASE eq 'RESPONSE') {
			if ($line=~/^([<|>].*ms) (.*)/) {
				my ($ms, $line) = ($1, $2);
				my $resp = $AFRESP{$ms};
				# レコード登録 key = [コマンド, デバイス, タイムスタンプ, レスポンス]
				my @item = split(/\s+/, $line);
				my $readval = $item[1];
				my $writeval = $item[3];

				if (my $sumdevice = $DEVLIST{$device}) {
					# read 登録 
					{
						my $key = join(',', 'read', $device, $CURTIME, $resp);
						$RESPDAT{$key} += $readval;
					}
					# write 登録 
					{
						my $key = join(',', 'write', $device, $CURTIME, $resp);
						$RESPDAT{$key} += $writeval;
					}
					# read 登録 
					{
						my $key = join(',', 'read', $sumdevice, $CURTIME, $resp);
						$RESPSUMDAT{$key} += $readval;
					}
					# write 登録 
					{
						my $key = join(',', 'write', $sumdevice, $CURTIME, $resp);
						$RESPSUMDAT{$key} += $writeval;
					}
				}
			}
		}
	}
	close(IN);

	# デバイス別サマリ
	$self->repsumdat(\%DEVLISTALL, \%CNTDAT, \%SUMDAT, $data_info);
	# デバイス別詳細
	$self->repdetdat(\%DEVLIST, \%CTLLIST, \%DEVCNT, \%AFDEV, \%DETAILDAT, \%DATELIST, $data_info);		
	# 転送サイズ
	$self->reptransdat(\%BLOCKLIST, \%DEVLIST, \%RAIDLIST, \%DATELIST, \%TRANSDAT, \%IOSUFFIX, $INTERVAL, $data_info);
	# 転送サイズ(サマリ)
	$self->reptransdatsum(\%BLOCKLIST, \%AFDEV, \%DATELIST, \%TRANSSUMDAT, \%IOSUFFIX, $INTERVAL, $data_info);	
	# レスポンス
	$self->represpdat(\%RESPLIST, \%DEVLIST, \%DATELIST, \%RESPDAT, \%IOSUFFIX, $INTERVAL, $data_info);
	# レスポンス(サマリ)
	$self->represpdatsum(\%RESPLIST, \%AFDEV, \%DATELIST, \%RESPSUMDAT, \%IOSUFFIX, $INTERVAL, $data_info);	
	# ライトキャッシュ分布
	$self->repwbchist(\@WBCPCTLIST, \%HOSTLIST, \%DATELIST, \%WBCDAT, $INTERVAL, $data_info);		
	# $self->repwbconoff();		# ライトキャッシュ分布
	# ホスト別サマリ
	$self->rephostdat(\%RAIDLIST, \%DATELIST, \%HOSTDAT, $INTERVAL, $data_info);		

	return 1;
}

sub represpdatsum {
	my ($self, $RESPLIST, $AFDEV, $DATELIST, $RESPSUMDAT, $IOSUFFIX, $INTERVAL, $data_info) = @_;
	my @headers = ();

	for my $item (sort keys %$RESPLIST) {
		$item=~s/(\<|\.)//g;
		$item=~s/\>.*$/etc/g;
		push(@headers, $item);
	}
	for my $device(sort keys %$AFDEV) {
		for my $cmd ('read', 'write') {
			my %lines = ();
			for my $tm(sort keys %$DATELIST) {
				my $line = '';
				for my $resp(sort keys %$RESPLIST) {
					my $key = join(',', $cmd, $device, $tm, $resp);

					my $val = $RESPSUMDAT->{$key} || 0;
					$val = $val / $INTERVAL;
					$line .= sprintf(" %9.1f", $val);
					$lines{$tm} = $line;
				}
			}
			my $host = $data_info->postfix;
			my $metric = sprintf("RefAFCtlElapse%s", $IOSUFFIX->{$cmd});
			$data_info->regist_device($host, 'Storage', $metric, $device, $device, \@headers);
			$data_info->simple_report("Storage/$host/device/${metric}__${device}.txt", \%lines, \@headers);
		}
	}
}

sub represpdat {
	my ($self, $RESPLIST, $DEVLIST, $DATELIST, $RESPDAT, $IOSUFFIX, $INTERVAL, $data_info) = @_;
	my @headers = ();

	for my $item (sort keys %$RESPLIST) {
		$item=~s/(\<|\.)//g;
		$item=~s/\>.*$/etc/g;
		push(@headers, $item);
	}

	for my $device(sort keys %$DEVLIST) {
		for my $cmd ('read', 'write') {
			my %lines = ();
			for my $tm(sort keys %$DATELIST) {
				my $line = '';
				for my $resp(sort keys %$RESPLIST) {
					my $key = join(',', $cmd, $device, $tm, $resp);

					my $val = $RESPDAT->{$key} || 0;
					$val = $val / $INTERVAL;
					$line .= sprintf(" %9.1f", $val);
				}
				$lines{$tm} = $line;
			}
			my $host = $data_info->postfix;
			my $metric = sprintf("RefAFDevElapse%s", $IOSUFFIX->{$cmd});
			$data_info->regist_device($host, 'Storage', $metric, $device, $device, \@headers);
			$data_info->simple_report("Storage/$host/device/${metric}__${device}.txt", \%lines, \@headers);
		}
	}
}

sub reptransdatsum {
	my ($self, $BLOCKLIST, $AFDEV, $DATELIST, $TRANSSUMDAT, $IOSUFFIX, $INTERVAL, $data_info) = @_;
	my @headers = ();

	for my $item (sort keys %$BLOCKLIST) {
		if ($item=~m|<\s+(\d+)KB|) {
			push(@headers, sprintf("%04dkb", ($1>1000)?1000:$1 ));
		} elsif ( $item=~m/\>=.*/) {
			push(@headers, 'etc');
		}
	}
	for my $device(sort keys %$AFDEV) {
		for my $cmd ('read', 'write') {
			my %lines = ();
			for my $tm(sort keys %$DATELIST) {
				my $line = '';
				for my $blk(sort keys %$BLOCKLIST) {
					my $key = join(',', $cmd, $device, $tm, $blk);
					my $val = $TRANSSUMDAT->{$key} || 0;
					$val = $val / $INTERVAL;
					$line .= sprintf(" %9.1f", $val);
				}
				$lines{$tm} = $line;
			}
			my $host = $data_info->postfix;
			my $metric = sprintf("RefAFSize%s", $IOSUFFIX->{$cmd});
			$data_info->regist_device($host, 'Storage', $metric, $device, $device, \@headers);
			$data_info->simple_report("Storage/$host/device/${metric}__${device}.txt", \%lines, \@headers);
		}
	}
}

sub reptransdat {
	my ($self, $BLOCKLIST, $DEVLIST, $RAIDLIST, $DATELIST, $TRANSDAT, $IOSUFFIX, $INTERVAL, $data_info) = @_;
	my @headers = ();

	for my $item (sort keys %$BLOCKLIST) {
		if ($item=~m|<\s+(\d+)KB|) {
			push(@headers, sprintf("%04dkb", ($1>1000)?1000:$1 ));
		} elsif ( $item=~m/\>=.*/) {
			push(@headers, 'etc');
		}
	}
	for my $device(sort keys %$DEVLIST, sort keys %$RAIDLIST) {
		for my $cmd ('read', 'write') {
			my %lines = ();
			for my $tm(sort keys %$DATELIST) {
				my $line = '';
				for my $blk(sort keys %$BLOCKLIST) {
					my $key = join(',', $cmd, $device, $tm, $blk);
					my $val = $TRANSDAT->{$key} || 0;
					$val = $val / $INTERVAL;
					$line .= sprintf(" %9.1f", $val);
				}
				$lines{$tm} = $line;
			}
			my $host = $data_info->postfix;
			my $metric = sprintf("RefAFSize%s", $IOSUFFIX->{$cmd});
			$data_info->regist_device($host, 'Storage', $metric, $device, $device, \@headers);
			$data_info->simple_report("Storage/$host/device/${metric}__${device}.txt", \%lines, \@headers);
		}
	}
}

sub repwbchist {
	my ($self, $WBCPCTLIST, $HOSTLIST, $DATELIST, $WBCDAT, $INTERVAL, $data_info) = @_;
	# 100pct
	my @headers = map { sprintf("%03dpct", $_); } @$WBCPCTLIST;

	for my $device(sort keys %$HOSTLIST) {
		my %lines = ();
		for my $tm(sort keys %$DATELIST) {
			my $line = '';
			for my $item (@$WBCPCTLIST) {
				my $key = join(',', $device, $tm, $item);
				my $val = $WBCDAT->{$key} || 0;
				$val = $val / $INTERVAL;
				$line .= sprintf(" %9.1f", $val);
			}
			$lines{$tm} = $line;
		}
		my $host = $data_info->postfix;
		$data_info->regist_device($host, 'Storage', 'RefAFWBC', $device, $device, \@headers);
		$data_info->simple_report("Storage/$host/device/RefAFWBC__${device}.txt", \%lines, \@headers);
	}
}


sub repsumdat {
	my ($self, $DEVLISTALL, $CNTDAT, $SUMDAT, $data_info) = @_;
	my @headers = qw|device        rkb_s   rcmd_s      rrs   rhdd_s    wkb_s   wcmd_s      wrs   whdd_s|;

	my %lines;
	for my $device(sort keys %$DEVLISTALL) {
		my $line = '';
		for my $cmd('read', 'write') {
			my $key = join(',', $cmd, $device);
			my $cnt = $CNTDAT->{$key};
			next if ($cnt == 0);
			for my $item('kb_s', 'cmd_s', 'rs', 'hdd_s') {
				my $key = join(',', $cmd, $item, $device);
				my $val = $SUMDAT->{$key} || 0;
				$val = $val / $cnt;
				$line .= sprintf(" %8.2f", $val);
			}
		}
		$lines{$device} = $line;
	}
	my $host = $data_info->postfix;
	$data_info->simple_report("Storage/$host/device/RefAFSummary.txt", \%lines, \@headers);
}

sub rephostdat {
	my ($self, $RAIDLIST, $DATELIST, $HOSTDAT, $INTERVAL, $data_info) = @_;
	my @headers = qw|rcmd_s    wcmd_s   rhdd_s   whdd_s|;

	for my $device(sort keys %$RAIDLIST) {
		# open(F, ">$ODIR/RefAFRaid_$device.txt") or die;
		# print F $head;
		my %lines = ();
		for my $tm(sort keys %$DATELIST) {
			my $line = '';
			my $key;
			$key = join(',', 'read', $device, $tm);
			next if (!defined($HOSTDAT->{$key}));
			my $read = $HOSTDAT->{$key};
			$key = join(',', 'write', $device, $tm);
			my $write = $HOSTDAT->{$key};
			$key = join(',', 'rhdd_s', $device, $tm);
			my $rhdd_s = ($INTERVAL) ? ($HOSTDAT->{$key} / $INTERVAL) : 0;
			$key = join(',', 'whdd_s', $device, $tm);
			my $whdd_s = ($INTERVAL) ? ($HOSTDAT->{$key} / $INTERVAL) : 0;

			$line .= sprintf(" %8.2f %8.2f %8.2f %8.2f", $read, $write, $rhdd_s, $whdd_s);

			$lines{$tm} = $line;
		}
#print Dumper($HOSTDAT);exit;
		my $host = $data_info->postfix;
		$data_info->regist_device($host, 'Storage', 'RefAFRaid', $device, $device, \@headers);
		$data_info->simple_report("Storage/$host/device/RefAFRaid__${device}.txt", \%lines, \@headers);
	}
}

sub repdetdat {
	my ($self, $DEVLIST, $CTLLIST, $DEVCNT, $AFDEV, $DETAILDAT, $DATELIST, $data_info) = @_;
	my @headers = qw|kr_s rcmd_s rrs rhdd_s kw_s wcmd_s wrs whdd_s|;
	for my $device(sort keys %$DEVLIST, sort keys %$CTLLIST) {
		my %lines = ();
		for my $tm(sort keys %$DATELIST) {
			my $line = '';
			for my $cmd('read', 'write') {
				my $key = join(',', $cmd, $device, $tm);
				my $cnt = $DEVCNT->{$key};
				for my $item('kb_s', 'cmd_s', 'rs', 'hdd_s') {
					my $key = join(',', $cmd, $item, $device, $tm);
					my $unit = 1;
					if ($CTLLIST->{$device} && ($item eq 'rs' || $item eq 'hdd_s')) {
						my @_devices = split("\n", $AFDEV->{$device});
						$unit = scalar(@_devices);
					}
					my $val = $DETAILDAT->{$key} || 0;
					$val = $val / $unit;
					$line .= sprintf(" %8.2f", $val);
				}
			}
			$lines{$tm} = $line;
		}
		my $metric = defined($CTLLIST->{$device}) ? 'RefAFCtl' : 'RefAFDev';
		my $host = $data_info->postfix;
		$data_info->regist_device($host, 'Storage', $metric, $device, undef, \@headers);
		$data_info->simple_report("Storage/$host/device/${metric}__${device}.txt", \%lines, \@headers);
	}
}

1;
